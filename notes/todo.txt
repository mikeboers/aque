- enumerate all of the statuses:
    - creating
    - pending
    - cancelled
    - running (I don't know if this would actually exist though)
    - success
    - error

- aque-xargs should match as much of xargs as we need
- aque-kill should kill a task
    - `aque-kill -r` would kill all dependencies

- send "task_status" -> "running" when a task starts executing

- workers should actually capture tasks

    # This will also schedule a heartbeat.
    # By default assume a 30s timeout.
    if not broker.capture(tid):
        continue

    try:
        xxx
    finally:
        broker.release(tid)

    - broker will need to synchronize time with the server:
        '''select CURRENT_TIME''' and calculate the offset


- reconsider adding children to the graph. They could be exactly the same as
  dependencies, except that they inherit from their parent.

  - children should not be under their parent as far as priority is concerned
    as that will introduce inefficiencies for our IO prioritization

  - it seems the tough problem is mostly determining how to present tasks
    in the Web UI.

- make it easier to not kill your production database when testing

- worker should be able to schedule a listener on the broker for when there
  are new tasks so that it can immediately wake up

    broker.init_worker(self)
    broker will then call worker.wake() when there is new pending work

- fork before running tasks
    - broker.did_fork() to repair whatever connections

- document relationships of queues, brokers, task prototypes, and futures.
