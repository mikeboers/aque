Overview
========

- Queue should expose the futures executor API:
    queue.submit(func, *args, **kwargs)
    queue.submit_ex(func, args, kwargs, **opts)


- Can tasks be represented by dicts alone?

    - They could be, but then how do you do local execution nicely?
    
    - Figure out how to hook the YAML encoder, and then use that for serializing.
        - See: yaml.add_constructor

- Queue.submit should return futures with IDs.
    - Futures should have children and dependencies lists to facilitate
      the submission process.
- The user's Tasks should never have an ID as they are prototypes.

- rename taskproperty.reduce/expand to dumps/loads or encode/decode?
- document:
    - data model of Tasks
    - relationships of queues, brokers, tasks, and futures.

- create a backend or broker class that handles all the communication with the DB
- create a Future which references the broker to get stuff

- migrate all results/error info to the Future class
- task.run() returns a Future, and the task object is not affected

- sync tasks could spawn threads, so Task.run() should have a timeout?
    - start all of the dependencies and children, and then wait for them all to be non-pending
    - will need to move the linearize logic into the run method
- only retry tasks that errored; re-use successful results
- error handling for sync tasks
- resuming sync tasks
- async running
    - submit all of the dependencies and children to the queue first
