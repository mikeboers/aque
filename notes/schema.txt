
Definitions
===========

- $base is the queue name
- $db is the database ID (defaults to 0)

- $worker is the name of a worker, usually the hostname
- $jid is a task ID: a unique string; some sort of UUID. If we deny the use of dots they can be used to specify subtasks. We should also not allow slashes to make neater URLs.


Global State
============

- "$base:task_counter" -> integer primary key

- "$base:pending_tasks" -> list of top-level tasks that are not complete
- "$base:complete_tasks" -> list of top-level tasks that are complete (errored or not)

- "$base@$db:task:$jid:status" -> channel that receives status changes of tasks

- "$base:workers" -> list of all worker IDs
- "$base:worker:$worker" -> hash of worker info, such as IP, hostname, PID, starttime, etc.


Tasks
====

- "$base:task:$jid" -> hash of task metadata

    - "status" -> "pending", "success", "error"

    - "last_capture" -> ID of the last capture attempt
    - "last_active" -> time of last capture or ping
    - "last_worker" -> worker ID

    - "type" -> "generic", "shell", "python", "range", "set"
    - "priority" -> integer base priority value; higher priorities run first

    - "requirements" -> JSON dict of requirements: cores, mem, platform, licenses, etc
    - "dependencies" -> JSON list of tasks which must complete successfully
    - "children" -> JSON list of child IDs

    - "user" and "group" -> run as these
    - "cwd" or "pwd" or "chdir" -> run here

    - "description" -> for human consumption

    - "duration_hint" -> guess as to duration so that longer tasks can be prioritized
    - "io_priority_hints" -> JSON list of paths where this task might do IO, so that the IO prioritizer can work
    
    - "args" and "kwargs"
    - OR "package" -> JSON dict of data to pass to handler

        - "func" -> for "generic" and "callable" tasks
        - "args" -> for shell or Python
        - "kwargs" -> for Python
